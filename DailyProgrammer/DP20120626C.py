"""
The ADFGVX cipher described in today's intermediate problem turned out to be quite a challenge for the Allied powers,
but it was finally cracked by the French cryptanalyst Georges Painvin. It is said that the work was so difficult and
involved such complex techniques that it made him physically break down from the fatigue. His method required lots of
similar messages encrypted during periods of high traffic.

Today we have an advantage that Painvin didn't have: massive computational power at our fingertips. Your difficult task
for the day is to try and crack a message that have been encrypted using the ADFGVX cipher as defined in today's
intermediate problem, without knowing either of the keys. To make the task a little bit easier, I'll give you a few
hints regarding the message and how it's been encrypted:

    The cleartext is in English
    The substitution key is not any random permutation of the alphabet, it is simply a caesar shift of the alphabet. So,
    for instance, it could be 'BCDEFGHIKLMNOPQRSTUVWXYZ0123456789 A' (a caesar shift of 1) or
    'CDEFGHIKLMNOPQRSTUVWXYZ0123456789 AB' (a caesar shift of 2), etc. etc.
    The transposition key is an english word less than 13 characters long.

Those hints should be enough for you to be able to crack it, but if no one has succeeded in 24 hours, I'll give a few
more hints. If you have an idea about how to solve it, but isn't quite sure, I encourage you to post your thoughts so
others can see them and maybe develop on them.

Here is the ciphertext:

VGVFFDXFAAVVXGAFAVAAGFAVAFAGVGXXAAVFGVAXGGVVGGXFGVGDVGXGVAGGGDXDVFGFAFVGGVAGGFG
DGFAXGAGAXGVGAAGDGFXDXVAGVVAXGVGVGFVVAGXDVDGAGDGFXVGXAXGGXGVXGVVDGDGGXDADGGVGAV
AGGDXDXVGGGVGXGFXFXFGVXXAFGDGXDAXXAGVFVVAVVGGVDVXAXAFDGVDXVAAVXAFVFGVAXVFADDAVF
AFGVGVGFDVADVDVVXGXGGDVGXGVFGGAVADAFVFAGGFXXGFGVXFVFXAVFGFAFGVGFAVAAVFGFVAAVVVG
DVAAXVGXDGDGGAGVDVGXDAXADGXGGADGFAFXGXVXVVVAFXXVFVVAAGVXXGGXADGAGFXFGFAGVFVVAFA
DXDGGGDGXAFADGDAFVDGFVGAGGXGFXDXGGFXXAGADXXAVXFXFAAXGVVAGVFVVVGVFDDVGDFVGXFXDXF
DXVGVGAVXDDFAFVFDGVFGFGDGGVGXGVFAFGFVGVXVGVGXFVVXGGDAXGFADAXGFVVVFDFAFAFAFVFVGG
GDGGFGFVFXXVFADVFXXXFVVXDAFADGFVGGFGGAFXXXGVFGFGDXFAVAFVFXDGVVXXDXFGFXDVXVFXXGX
GGAAXFAFGVXFXDAFGFGGGXADVGAGXVGFXFVVGDGDAGVGGGVFVGGXGGVFAGVDXFDXAXGGVDAFAFAFVAG
GADXGXDVFXFVGGDAXXFAXXFVVGVVGGFXFXGXGVFADGVDXFXGFXXFVGVFGFAGGGVFVDVFVFGDVGGVAGX
XVDGFAAVDGXGFXGVAGFGGGFGGVVGDXGAFXFGVDXAAVFAFVGDGVFADVGVFAVGAXFADGGXFXFGDAVGFXF
AGGXXFVGXGAAVGVDAXGAGDXFGXVFVXVFGFVDXAGGXFAGAFXGAVVAADXVXGXXVGXDVXVFXVADXDVAXGF
FVDGGVDGVXDGGDDXFVXGDVVGVGDGXAFXFGVAXVFVFXFXDVDVXVFVGGVADVXAGGAXFAGGXAXAFAGXGGX
GVXDXGVFVFAVXVVFGVAFAFXFAGDXVGGVAXAGVFAFVVXFXGXFGFAVVFVDGGAFGVAGVXVDAGXGGGGDXFV
FAFVFAXGDVGGFAFVFVFAFDXFVFXVVGADXFGVAFGGVFAAVXVDXFGVGFXFAGGGAGVFVGVGGDGXXDGVXGA
DAVXGVDAFVVGGVGXDGFXGXDXGXGAFXFXVGDGDVFDGADADVFVXADGVAVXAADVGVDAGXAAFAVAGXGVGVF
XGVDGDGFAGVFAXXDGVAGVGVXAFVFVFADXFADAXXDVGXFGDAXDDAXGGXGFAVGFDGXXAXVDAGVFGGXFGG
XGAGXFVGGXAFVDAGXXXFXVXDXXAVXFXDAFVGVGGGADGGGGADAXGDVDGXVDDXVGAVAGVDVVAFXFVDAGX
VGFXFXDGAVXAFVFAFVDVGGVXFVGVDXXGAGAVFVXVGXFXFXFADXGXFGVVVVFXDGFXFXDGDGGGAVFXFAA
VGFADVFVDGXGGAGGFXVGFVVVFADXDVXGFVDVGVDVDGVXFXVVDGXAGGGGFVGGGVFXFVDAGGVVVAGXGGD
ADAVADGDVDXXAGADGXXGGFVGADXFGFVDAGGDVFAGAFXGVGGVVVAFGXGXGGGFVGXGAGXAGDGAVFXDGXV
GVVVGVGGVGVXDGDGXVXVDXDAVGDGDXGXGVDVVGFXFXXGDXFGDDDAVXDAAXAGXVFVVAGXDXGXGVFGFVA
VXXFGGXFDVXAVDGDAGAGXXXFAXGXVDVFAGADDGXDGDGFVFXGGFAXDXGXVFGFAGGFVVXDGVGDGXGXGGV
XGFVVXGVXXVVFVGGFVDGDXGAFGFXFVFAGGFAVADAVGGDDVFXFXGVFXGVXXGXGXGDGXAGXAFGGGGFVFV
GAXADGDGVXVAFVFAGAFXGAGGDXXGDGGDGXVVFVDGFGGVAGGGDVXXFXDVVGFXVXVGDVVGFXVGGXFVFAX
AFXVGDGXXDVGVGXGAAGGGDAFVFGGGFAGVVGVVXAXAFVDGGGFXGDXGVVVGGVFADGVAGADXDGFVGVGXGX
DXAGFGGGGVGXFD
"""

import numpy as np
from collections import defaultdict
from DP20120626B import reorder_decode, adfgvx_decode, subs_array, decrypt_adfgvx


def valid_transkey_lengths(enc):
    return [n for n in range(2, 12) if len(enc) % n == 0]


def freq_analysis(enc):
    res1 = defaultdict(int)
    enc = enc.reshape(-1, 1)
    for n in range(0, len(enc), 2):
        res1[enc[n][0]] += 1
    print(res1)

    res2 = defaultdict(int)
    enc = enc.reshape(-1, 1)
    for n in range(1, len(enc), 2):
        res2[enc[n][0]] += 1
    print(res2)


def get_words(length=0):
    with open('words.txt', 'r') as file:
        data = file.read()

    if length:
        return [d.upper() for d in data.split() if len(d) == length and d.isalpha()]
    else:
        return [d.upper() for d in data.split() if d.isalpha()]


def magic_decryptor(code, key_length):
    words = get_words(key_length)
    full_words = get_words()

    res_count = 0
    res_word = '_'
    res_shift = -1
    for w in words:
        caesar = shift_list(code, w)
        for p in caesar:
            result = decrypt_adfgvx(code, p, w)
            res_sum = sum([1 for r in result.split() if r in full_words])
            if res_sum > res_count:
                res_count = res_sum
                res_word = w
                res_shift = p
        # configuration
        # if res_count > 100:
        #     break
    print(res_word, res_count, res_shift)
    print(decrypt_adfgvx(code, res_shift, res_word))


def caesar_shift(n):
    alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ0123456789 '
    return alphabet[n:] + alphabet[:n]


def caesar_key(combination, alpha):
    alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ0123456789 '
    cipher = ''.join(reversed('ADFGVX'))
    n = 0
    for a in combination:
        n = (6 * n) + cipher.index(a)
    return caesar_shift(n + alphabet.index(alpha) + 1)


def shift_list(code, trans_key):
    answer = reorder_decode(code, trans_key)
    answer = ''.join(answer.reshape(1, -1)[0])

    code_dict = defaultdict(int)
    length = len(answer)
    for i in range(0, length, 2):
        code_dict[answer[i:i+2]] += 1

    return [caesar_key(c, w) for c in code_dict for w in ['E', ' '] if code_dict[c] > 100]


def main():
    enc = ("VGVFFDXFAAVVXGAFAVAAGFAVAFAGVGXXAAVFGVAXGGVVGGXFGVGDVGXGVAGGGDXDVFGFAFVGGVAGGFG"
           "DGFAXGAGAXGVGAAGDGFXDXVAGVVAXGVGVGFVVAGXDVDGAGDGFXVGXAXGGXGVXGVVDGDGGXDADGGVGAV"
           "AGGDXDXVGGGVGXGFXFXFGVXXAFGDGXDAXXAGVFVVAVVGGVDVXAXAFDGVDXVAAVXAFVFGVAXVFADDAVF"
           "AFGVGVGFDVADVDVVXGXGGDVGXGVFGGAVADAFVFAGGFXXGFGVXFVFXAVFGFAFGVGFAVAAVFGFVAAVVVG"
           "DVAAXVGXDGDGGAGVDVGXDAXADGXGGADGFAFXGXVXVVVAFXXVFVVAAGVXXGGXADGAGFXFGFAGVFVVAFA"
           "DXDGGGDGXAFADGDAFVDGFVGAGGXGFXDXGGFXXAGADXXAVXFXFAAXGVVAGVFVVVGVFDDVGDFVGXFXDXF"
           "DXVGVGAVXDDFAFVFDGVFGFGDGGVGXGVFAFGFVGVXVGVGXFVVXGGDAXGFADAXGFVVVFDFAFAFAFVFVGG"
           "GDGGFGFVFXXVFADVFXXXFVVXDAFADGFVGGFGGAFXXXGVFGFGDXFAVAFVFXDGVVXXDXFGFXDVXVFXXGX"
           "GGAAXFAFGVXFXDAFGFGGGXADVGAGXVGFXFVVGDGDAGVGGGVFVGGXGGVFAGVDXFDXAXGGVDAFAFAFVAG"
           "GADXGXDVFXFVGGDAXXFAXXFVVGVVGGFXFXGXGVFADGVDXFXGFXXFVGVFGFAGGGVFVDVFVFGDVGGVAGX"
           "XVDGFAAVDGXGFXGVAGFGGGFGGVVGDXGAFXFGVDXAAVFAFVGDGVFADVGVFAVGAXFADGGXFXFGDAVGFXF"
           "AGGXXFVGXGAAVGVDAXGAGDXFGXVFVXVFGFVDXAGGXFAGAFXGAVVAADXVXGXXVGXDVXVFXVADXDVAXGF"
           "FVDGGVDGVXDGGDDXFVXGDVVGVGDGXAFXFGVAXVFVFXFXDVDVXVFVGGVADVXAGGAXFAGGXAXAFAGXGGX"
           "GVXDXGVFVFAVXVVFGVAFAFXFAGDXVGGVAXAGVFAFVVXFXGXFGFAVVFVDGGAFGVAGVXVDAGXGGGGDXFV"
           "FAFVFAXGDVGGFAFVFVFAFDXFVFXVVGADXFGVAFGGVFAAVXVDXFGVGFXFAGGGAGVFVGVGGDGXXDGVXGA"
           "DAVXGVDAFVVGGVGXDGFXGXDXGXGAFXFXVGDGDVFDGADADVFVXADGVAVXAADVGVDAGXAAFAVAGXGVGVF"
           "XGVDGDGFAGVFAXXDGVAGVGVXAFVFVFADXFADAXXDVGXFGDAXDDAXGGXGFAVGFDGXXAXVDAGVFGGXFGG"
           "XGAGXFVGGXAFVDAGXXXFXVXDXXAVXFXDAFVGVGGGADGGGGADAXGDVDGXVDDXVGAVAGVDVVAFXFVDAGX"
           "VGFXFXDGAVXAFVFAFVDVGGVXFVGVDXXGAGAVFVXVGXFXFXFADXGXFGVVVVFXDGFXFXDGDGGGAVFXFAA"
           "VGFADVFVDGXGGAGGFXVGFVVVFADXDVXGFVDVGVDVDGVXFXVVDGXAGGGGFVGGGVFXFVDAGGVVVAGXGGD"
           "ADAVADGDVDXXAGADGXXGGFVGADXFGFVDAGGDVFAGAFXGVGGVVVAFGXGXGGGFVGXGAGXAGDGAVFXDGXV"
           "GVVVGVGGVGVXDGDGXVXVDXDAVGDGDXGXGVDVVGFXFXXGDXFGDDDAVXDAAXAGXVFVVAGXDXGXGVFGFVA"
           "VXXFGGXFDVXAVDGDAGAGXXXFAXGXVDVFAGADDGXDGDGFVFXGGFAXDXGXVFGFAGGFVVXDGVGDGXGXGGV"
           "XGFVVXGVXXVVFVGGFVDGDXGAFGFXFVFAGGFAVADAVGGDDVFXFXGVFXGVXXGXGXGDGXAGXAFGGGGFVFV"
           "GAXADGDGVXVAFVFAGAFXGAGGDXXGDGGDGXVVFVDGFGGVAGGGDVXXFXDVVGFXVXVGDVVGFXVGGXFVFAX"
           "AFXVGDGXXDVGVGXGAAGGGDAFVFGGGFAGVVGVVXAXAFVDGGGFXGDXGVVVGGVFADGVAGADXDGFVGVGXGX"
           "DXAGFGGGGVGXFD")

    # key_length = valid_transkey_lengths(enc)
    # 2, 4, 11

    np.set_printoptions(threshold=np.nan)

    key_length = 11
    magic_decryptor(enc, key_length)


if __name__ == "__main__":
    main()
